use rust_decimal::prelude::ToPrimitive;
use std::str::FromStr;
use std::sync::Arc;
use std::time::{Duration, Instant};

use axum::body::{Body, Bytes};
use axum::extract::State;
use axum::http::{HeaderMap, Method, StatusCode, Uri};
use axum::response::Response;
use uuid::Uuid;

use crate::errors::AppError;
use crate::middleware;
use crate::middleware::fields::RequestContext;
use crate::models::cost::{self, extract_model, extract_usage};
use crate::models::policy::{Action, RedactDirection, RedactOnMatch, TriggeredAction};
use crate::proxy;
use crate::vault::SecretStore;
use crate::AppState;

/// The main handler for all proxied requests.
#[tracing::instrument(skip(state, headers, body), fields(req_id = %uuid::Uuid::new_v4()))]
pub async fn proxy_handler(
    State(state): State<Arc<AppState>>,
    method: Method,
    uri: Uri,
    headers: HeaderMap,
    body: Bytes,
) -> Result<Response, AppError> {
    let start = Instant::now();
    let request_id = Uuid::new_v4();

    // Copy agent name header before consuming request
    let agent_name = headers
        .get("X-AIlink-Agent-Name")
        .or_else(|| headers.get("user-agent"))
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string());

    // Copy idempotency key for HITL
    let idempotency_key = headers
        .get("X-AIlink-Idempotency-Key")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string());

    // TEST HOOK: Extract cost/token/latency override headers for integration testing.
    // SEC: Compile-time gated — these headers are STRIPPED from release binaries.
    // Build with `--features test-hooks` to enable. Never use in production.
    #[cfg(feature = "test-hooks")]
    let (test_cost_override, test_tokens_override, test_latency_override) = {
        let cost = headers
            .get("x-ailink-test-cost")
            .and_then(|v| v.to_str().ok())
            .and_then(|s| rust_decimal::Decimal::from_str(s).ok());
            
        let tokens = headers
            .get("x-ailink-test-tokens")
            .and_then(|v| v.to_str().ok())
            .and_then(|s| {
                let parts: Vec<&str> = s.split(',').collect();
                if parts.len() == 2 {
                    if let (Ok(p), Ok(c)) = (parts[0].trim().parse::<u32>(), parts[1].trim().parse::<u32>()) {
                        Some((p, c))
                    } else { None }
                } else { None }
            });
            
        let latency = headers
            .get("x-ailink-test-latency")
            .and_then(|v| v.to_str().ok())
            .and_then(|s| s.parse::<u64>().ok());
            
        (cost, tokens, latency)
    };
    #[cfg(not(feature = "test-hooks"))]
    let (test_cost_override, test_tokens_override, test_latency_override) = (None::<rust_decimal::Decimal>, None::<(u32, u32)>, None::<u64>);

    // ── Phase 4: Attribution headers ──────────────────────────
    let user_id = headers
        .get("x-user-id")
        .and_then(|v| v.to_str().ok())
        .map(String::from);
    let tenant_id = headers
        .get("x-tenant-id")
        .and_then(|v| v.to_str().ok())
        .map(String::from);
    let external_request_id = headers
        .get("x-request-id")
        .and_then(|v| v.to_str().ok())
        .map(String::from);

    // ── Phase 5: Trace / session headers ─────────────────────
    let session_id = headers
        .get("x-session-id")
        .and_then(|v| v.to_str().ok())
        .map(String::from);

    // ── Phase 6: Custom properties ────────────────────────────
    // X-Properties: {"env":"prod","run_id":"agent-run-42","customer":"acme"}
    // Arbitrary JSON key-values attached to every audit log for this request.
    // Stored as JSONB and GIN-indexed for fast filtering.
    let custom_properties: Option<serde_json::Value> = headers
        .get("x-properties")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| serde_json::from_str(s).ok());

    // W3C Trace Context: parse `traceparent` header if present.
    // Format: 00-{trace_id}-{parent_id}-{flags}
    // We prefer traceparent over x-parent-span-id when both are present.
    let (w3c_trace_id, w3c_parent_id) = headers
        .get("traceparent")
        .and_then(|v| v.to_str().ok())
        .and_then(|tp| {
            let parts: Vec<&str> = tp.splitn(4, '-').collect();
            if parts.len() == 4 {
                Some((parts[1].to_string(), parts[2].to_string()))
            } else {
                tracing::debug!(traceparent = %tp, "malformed traceparent header, ignoring");
                None
            }
        })
        .map(|(t, p)| (Some(t), Some(p)))
        .unwrap_or((None, None));

    let parent_span_id = w3c_parent_id
        .or_else(|| {
            headers
                .get("x-parent-span-id")
                .and_then(|v| v.to_str().ok())
                .map(String::from)
        });

    if let (Some(ref tid), Some(ref pid)) = (&w3c_trace_id, &parent_span_id) {
        tracing::debug!(
            trace_id = %tid,
            parent_span_id = %pid,
            req_id = %request_id,
            "W3C trace context received"
        );
    }

    // Detect streaming request (will be confirmed after body parse)
    let is_streaming_req = crate::models::llm::is_streaming_request(&body);

    // Copy original Content-Type before consuming request
    let original_content_type = headers
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/json")
        .to_string();

    // -- 1. Extract virtual token --
    let token_str = extract_bearer_token(&headers)?;

    // -- 2. Resolve token --
    let token = state
        .db
        .get_token(&token_str)
        .await
        .map_err(AppError::Internal)?
        .ok_or(AppError::TokenNotFound)?;

    if !token.is_active {
        return Err(AppError::TokenNotFound);
    }

    // Check token expiration
    if let Some(exp) = token.expires_at {
        if exp < chrono::Utc::now() {
            tracing::warn!(
                token_id = %token.id,
                expired_at = %exp,
                "proxy: token rejected — expired"
            );
            return Err(AppError::TokenNotFound);
        }
    }

    // -- 2.1 Parse per-token circuit breaker configuration --
    let cb_config: crate::proxy::loadbalancer::CircuitBreakerConfig = token
        .circuit_breaker
        .as_ref()
        .and_then(|v| serde_json::from_value(v.clone()).ok())
        .unwrap_or_default();

    // -- 3. Load policies --
    let path = uri.path().to_string();

    let policies = state
        .db
        .get_policies_for_token(&token.policy_ids)
        .await
        .map_err(AppError::Internal)?;

    // -- 3.1 Parse request body as JSON (for body inspection) --
    let mut parsed_body: Option<serde_json::Value> = if !body.is_empty() {
        serde_json::from_slice(&body).ok()
    } else {
        None
    };

    // -- 3.2 Evaluate PRE-FLIGHT policies --
    // Load usage counters from Redis for condition evaluation
    let usage_counters = {
        let mut counters = std::collections::HashMap::new();
        let mut conn = state.cache.redis();
        let now = chrono::Utc::now();

        let spend_daily_key = format!("spend:{}:daily:{}", token.id, now.format("%Y-%m-%d"));
        let spend_monthly_key = format!("spend:{}:monthly:{}", token.id, now.format("%Y-%m"));

        // Request counting keys
        let req_daily_key = format!("req:{}:daily:{}", token.id, now.format("%Y-%m-%d"));
        let req_hourly_key = format!("req:{}:hourly:{}", token.id, now.format("%Y-%m-%d:%H"));

        // Pipeline:
        // 1. Get Spend (Daily + Monthly)
        // 2. Incr Requests (Daily + Hourly)
        // We use a pipeline to minimize RTT.
        let mut pipe = redis::pipe();
        pipe.get(&spend_daily_key)
            .get(&spend_monthly_key)
            .incr(&req_daily_key, 1)
            .expire(&req_daily_key, 90000)
            .ignore() // Daily + buffer
            .incr(&req_hourly_key, 1)
            .expire(&req_hourly_key, 4000)
            .ignore(); // Hourly + buffer

        let (spend_daily, spend_monthly, req_daily, req_hourly): (
            Option<f64>,
            Option<f64>,
            u64,
            u64,
        ) = pipe
            .query_async(&mut conn)
            .await
            .unwrap_or((None, None, 0, 0));

        if let Some(v) = spend_daily {
            counters.insert("spend_today_usd".to_string(), v);
        }
        if let Some(v) = spend_monthly {
            counters.insert("spend_month_usd".to_string(), v);
        }

        counters.insert("requests_today".to_string(), req_daily as f64);
        counters.insert("requests_this_hour".to_string(), req_hourly as f64);

        counters
    };

    // Extract client IP from X-Forwarded-For or X-Real-IP
    let client_ip_str = headers
        .get("x-forwarded-for")
        .or_else(|| headers.get("x-real-ip"))
        .and_then(|v| v.to_str().ok())
        .map(|s| s.split(',').next().unwrap_or(s).trim().to_string());

    // Scope the RequestContext borrow so we can mutate parsed_body after evaluation
    let (outcome_actions, shadow_violations, pre_async_triggered) = {
        let ctx = RequestContext {
            method: &method,
            path: &path,
            uri: &uri,
            headers: &headers,
            body: parsed_body.as_ref(),
            body_size: body.len(),
            agent_name: agent_name.as_deref(),
            token_id: &token.id,
            token_name: &token.name,
            project_id: &token.project_id.to_string(),
            client_ip: client_ip_str.as_deref(),
            response_status: None,
            response_body: None,
            response_headers: None,
            usage: usage_counters.clone(),
        };

        let outcome = middleware::policy::evaluate_pre_flight(&policies, &ctx);
        (outcome.actions, outcome.shadow_violations, outcome.async_triggered)
    };
    // ctx is now dropped — parsed_body can be mutated

    // -- X-AILink-Guardrails header opt-in (per-request guardrails, no policy config needed) --
    // Header format:  X-AILink-Guardrails: pii_redaction,prompt_injection
    // Each recognised preset injects synthetic TriggeredAction entries at the front of the queue.
    let mut outcome_actions = outcome_actions;
    if let Some(guardrail_header) = headers
        .get("x-ailink-guardrails")
        .and_then(|v| v.to_str().ok())
    {
        let mut header_actions: Vec<TriggeredAction> = Vec::new();
        for preset in guardrail_header.split(',').map(str::trim).filter(|s| !s.is_empty()) {
            let action = match preset {
                "pii_redaction" => Some(Action::Redact {
                    direction: RedactDirection::Both,
                    patterns: ["ssn","email","credit_card","phone","api_key","iban","dob","ipv4"]
                        .iter().map(|s| s.to_string()).collect(),
                    fields: vec![],
                    on_match: RedactOnMatch::Redact,
                }),
                "pii_block" => Some(Action::Redact {
                    direction: RedactDirection::Request,
                    patterns: ["ssn","email","credit_card","phone"]
                        .iter().map(|s| s.to_string()).collect(),
                    fields: vec![],
                    on_match: RedactOnMatch::Block,
                }),
                "prompt_injection" => Some(Action::ContentFilter {
                    block_jailbreak: true,
                    block_harmful: true,
                    block_code_injection: true,
                    topic_allowlist: vec![],
                    topic_denylist: vec![],
                    custom_patterns: vec![],
                    risk_threshold: 0.3,
                    max_content_length: 0,
                }),
                other => {
                    tracing::warn!(preset = other, "X-AILink-Guardrails: unrecognised preset, ignoring");
                    None
                }
            };
            if let Some(a) = action {
                header_actions.push(TriggeredAction {
                    policy_id: uuid::Uuid::nil(),
                    policy_name: format!("header-guardrail:{}", preset),
                    rule_index: 0,
                    action: a,
                });
            }
        }
        // Prepend header actions so they run before any configured policies
        header_actions.extend(outcome_actions);
        outcome_actions = header_actions;
    }

    let mut shadow_violations = shadow_violations;

    // -- 3.3 Execute enforced actions --
    let mut hitl_required = false;
    let mut hitl_decision = None;
    let mut hitl_timeout_str = "30m".to_string();
    let mut hitl_latency_ms = None;
    let mut policy_rate_limited = false;
    let mut header_mutations = middleware::redact::HeaderMutations::default();
    let mut redacted_by_policy: Vec<String> = Vec::new();
    // A/B experiment tracking — set by Split action
    let mut experiment_name: Option<String> = None;
    let mut variant_name: Option<String> = None;
    // DynamicRoute tracking — set by DynamicRoute action
    let mut dynamic_upstream_override: Option<String> = None;
    let mut dynamic_route_strategy: Option<String> = None;
    let mut dynamic_route_reason:   Option<String> = None;

    for triggered in &outcome_actions {
        match &triggered.action {
            // ── Allow ──
            Action::Allow => {
                // No-op
            }
            // ── Deny ──
            Action::Deny { status: _, message } => {
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &token.upstream_url, &policies, false, None, None,
                    user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                    session_id.clone(), parent_span_id.clone(),
                    custom_properties.clone(),
                );
                audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
                    policy: triggered.policy_name.clone(),
                    reason: message.clone(),
                });
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
                audit.emit(&state);
                
                // Phase 5: Emit notification + webhook
                let state_clone = state.clone();
                let project_id = token.project_id;
                let title = format!("Policy Violation: {}", triggered.policy_name);
                let body_msg = message.clone();
                let webhook_event = crate::notification::webhook::WebhookEvent::policy_violation(
                    &token.id,
                    &token.name,
                    &token.project_id.to_string(),
                    &triggered.policy_name,
                    message,
                );
                let webhook_urls = state.config.webhook_urls.clone();
                state.webhook.dispatch(&webhook_urls, webhook_event).await;
                tokio::spawn(async move {
                    let _ = state_clone
                        .db
                        .create_notification(
                            project_id,
                            "policy_violation",
                            &title,
                            Some(&body_msg),
                            None,
                        )
                        .await;
                });

                return Err(AppError::PolicyDenied {
                    policy: triggered.policy_name.clone(),
                    reason: message.clone(),
                });
            }

            // ── Rate Limit ──
            Action::RateLimit {
                window,
                max_requests,
                key,
            } => {
                let rl_key = match key {
                    crate::models::policy::RateLimitKey::PerToken => format!("rl:tok:{}", token.id),
                    crate::models::policy::RateLimitKey::PerAgent => {
                        format!("rl:agent:{}", agent_name.as_deref().unwrap_or("unknown"))
                    }
                    crate::models::policy::RateLimitKey::PerIp => format!(
                        "rl:ip:{}",
                        client_ip_str.as_deref().unwrap_or("unknown")
                    ),
                    crate::models::policy::RateLimitKey::PerUser => format!(
                        "rl:user:{}",
                        user_id.as_deref().unwrap_or(&token.id)
                    ),
                    crate::models::policy::RateLimitKey::Global => "rl:global".to_string(),
                };
                let window_secs = middleware::policy::parse_window_secs(window).unwrap_or(60);
                let count = state
                    .cache
                    .increment(&rl_key, window_secs)
                    .await
                    .map_err(AppError::Internal)?;

                if count > *max_requests {
                    let mut audit = base_audit(
                        request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                        &token.upstream_url, &policies, false, None, None,
                        user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                        session_id.clone(), parent_span_id.clone(),
                        custom_properties.clone(),
                    );
                    audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
                        policy: triggered.policy_name.clone(),
                        reason: "rate limit exceeded".to_string(),
                    });
                    audit.response_latency_ms = start.elapsed().as_millis() as u64;
                    audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
                    audit.emit(&state);

                    // Phase 5: Emit notification + webhook
                    let state_clone = state.clone();
                    let project_id = token.project_id;
                    let title = format!("Rate Limit Exceeded: {}", triggered.policy_name);
                    let body_msg = format!("Limit of {} requests per {}s reached", max_requests, window_secs);
                    let webhook_event = crate::notification::webhook::WebhookEvent::rate_limit_exceeded(
                        &token.id,
                        &token.name,
                        &token.project_id.to_string(),
                        &triggered.policy_name,
                        *max_requests,
                        window_secs,
                    );
                    let webhook_urls = state.config.webhook_urls.clone();
                    state.webhook.dispatch(&webhook_urls, webhook_event).await;
                    tokio::spawn(async move {
                        let _ = state_clone
                            .db
                            .create_notification(
                                project_id,
                                "rate_limit_exceeded",
                                &title,
                                Some(&body_msg),
                                None,
                            )
                            .await;
                    });

                    return Err(AppError::RateLimitExceeded);
                }
                policy_rate_limited = true;
            }

            // ── Override (body mutation) ──
            Action::Override { set_body_fields } => {
                if let Some(ref mut body_val) = parsed_body {
                    if let Some(obj) = body_val.as_object_mut() {
                        for (k, v) in set_body_fields {
                            obj.insert(k.clone(), v.clone());
                        }
                        tracing::info!(
                            policy = %triggered.policy_name,
                            fields = ?set_body_fields.keys().collect::<Vec<_>>(),
                            "applied body overrides"
                        );
                    }
                }
            }

            // ── Split (A/B traffic split) ──
            Action::Split { variants, experiment } => {
                if variants.is_empty() {
                    tracing::warn!(policy = %triggered.policy_name, "Split action has no variants, skipping");
                } else {
                    let total_weight: u32 = variants.iter().map(|v| v.weight).sum();
                    if total_weight == 0 {
                        tracing::warn!(policy = %triggered.policy_name, "Split action has zero total weight, skipping");
                    } else {
                        // Deterministic variant selection: derive a stable bucket from request_id bytes.
                        // XOR-fold the UUID bytes into a u32 so the same request_id always picks
                        // the same variant, ensuring stable assignment within a request.
                        let req_bytes = request_id.as_bytes();
                        let bucket_seed = req_bytes[0..4].iter().enumerate()
                            .fold(0u32, |acc, (i, &b)| acc ^ ((b as u32) << (i * 8)));
                        let bucket = bucket_seed % total_weight;
                        let mut cumulative: u32 = 0;
                        let mut chosen = &variants[0];
                        for variant in variants {
                            cumulative += variant.weight;
                            if bucket < cumulative {
                                chosen = variant;
                                break;
                            }
                        }
                        // Apply the chosen variant's body field overrides
                        if let Some(ref mut body_val) = parsed_body {
                            if let Some(obj) = body_val.as_object_mut() {
                                for (k, v) in &chosen.set_body_fields {
                                    obj.insert(k.clone(), v.clone());
                                }
                            }
                        }
                        // Track for audit log
                        experiment_name = experiment.clone();
                        variant_name = chosen.name.clone();
                        tracing::info!(
                            policy = %triggered.policy_name,
                            experiment = ?experiment,
                            variant = ?chosen.name,
                            weight = chosen.weight,
                            total_weight,
                            bucket,
                            fields = ?chosen.set_body_fields.keys().collect::<Vec<_>>(),
                            "A/B split: assigned variant"
                        );
                    }
                }
            }

            // ── DynamicRoute (smart model selection) ──
            Action::DynamicRoute { strategy, pool, fallback } => {
                let cb_cooldown = {
                    // Read CB cooldown from token's circuit breaker config (default 30s)
                    let cb: proxy::loadbalancer::CircuitBreakerConfig =
                        token.circuit_breaker
                            .as_ref()
                            .and_then(|v| serde_json::from_value(v.clone()).ok())
                            .unwrap_or_default();
                    cb.recovery_cooldown_secs
                };

                if let Some(decision) = proxy::smart_router::select_route(
                    strategy,
                    pool,
                    fallback.as_ref(),
                    &state.pricing,
                    &state.latency,
                    &state.lb,
                    &token.id,
                    cb_cooldown,
                ).await {
                    // Override model in body
                    if let Some(ref mut body_val) = parsed_body {
                        if let Some(obj) = body_val.as_object_mut() {
                            obj.insert("model".into(), serde_json::json!(decision.model));
                        }
                    }
                    tracing::info!(
                        policy     = %triggered.policy_name,
                        strategy   = %decision.strategy_used,
                        model      = %decision.model,
                        upstream   = %decision.upstream_url,
                        reason     = %decision.reason,
                        "dynamic_route: selected target"
                    );
                    dynamic_upstream_override = Some(decision.upstream_url);
                    dynamic_route_strategy    = Some(decision.strategy_used);
                    dynamic_route_reason      = Some(decision.reason);
                } else {
                    tracing::warn!(
                        policy = %triggered.policy_name,
                        "dynamic_route: no healthy target selected, proceeding with original model"
                    );
                }
            }

            // ── Throttle ──
            Action::Throttle { delay_ms } => {
                tracing::info!(delay_ms = delay_ms, policy = %triggered.policy_name, "throttling request");
                tokio::time::sleep(Duration::from_millis(*delay_ms)).await;
            }

            // ── HITL (handled below after all other pre-flight checks) ──
            Action::RequireApproval { timeout, .. } => {
                hitl_required = true;
                hitl_timeout_str = timeout.clone();
            }

            // ── Log ──
            Action::Log { level, tags } => match level.as_str() {
                "error" => {
                    tracing::error!(policy = %triggered.policy_name, tags = ?tags, "policy log")
                }
                "warn" => {
                    tracing::warn!(policy = %triggered.policy_name, tags = ?tags, "policy log")
                }
                _ => tracing::info!(policy = %triggered.policy_name, tags = ?tags, "policy log"),
            },

            // ── Tag (stored in audit) ──
            Action::Tag { key, value } => {
                tracing::info!(
                    policy = %triggered.policy_name,
                    tag_key = %key, tag_value = %value,
                    "policy tag"
                );
            }

            // ── Webhook (fire & forget for now) ──
            Action::Webhook {
                url, timeout_ms, ..
            } => {
                // SEC: SSRF validation for policy-defined webhook URLs
                if !is_safe_webhook_url(url) {
                    tracing::warn!(
                        policy = %triggered.policy_name,
                        url = %url,
                        "policy webhook blocked: SSRF protection"
                    );
                } else {
                    let url = url.clone();
                    let timeout_ms = *timeout_ms;
                    let summary = serde_json::json!({
                        "policy": triggered.policy_name,
                        "method": method.to_string(),
                        "path": path,
                        "agent": agent_name,
                        "token_id": token.id,
                    });
                    tokio::spawn(async move {
                        let client = reqwest::Client::new();
                        let _ = client
                            .post(&url)
                            .timeout(Duration::from_millis(timeout_ms))
                            .json(&summary)
                            .send()
                            .await;
                    });
                }
            }

            // ── Content Filter (Prompt Guardrails) ──
            Action::ContentFilter { .. } => {
                if let Some(ref body_val) = parsed_body {
                    let result = middleware::guardrail::check_content(body_val, &triggered.action);
                    if result.blocked {
                        let reason = result.reason.clone().unwrap_or_else(|| "Content filter blocked request".to_string());
                        tracing::warn!(
                            policy = %triggered.policy_name,
                            risk_score = %result.risk_score,
                            patterns = ?result.matched_patterns,
                            "content filter blocked request"
                        );
                        // P1.9: Return rich ContentBlocked error with matched patterns + confidence
                        // This feeds ContentBlockedError in the Python SDK with actionable details.
                        return Err(AppError::ContentBlocked {
                            reason: reason.clone(),
                            details: Some(serde_json::json!({
                                "policy": triggered.policy_name,
                                "reason": reason,
                                "matched_patterns": result.matched_patterns,
                                "confidence": result.risk_score,
                            })),
                        });
                    } else if !result.matched_patterns.is_empty() {
                        // Patterns matched but below threshold — log as warning
                        tracing::info!(
                            policy = %triggered.policy_name,
                            risk_score = %result.risk_score,
                            patterns = ?result.matched_patterns,
                            "content filter: patterns matched but below threshold"
                        );
                    }
                }
            }

            // ── Redact (pre-flight, request-side) ──
            Action::Redact { .. } => {
                if let Some(ref mut body_val) = parsed_body {
                    let result =
                        middleware::redact::apply_redact(body_val, &triggered.action, true);
                    if !result.matched_types.is_empty() {
                        tracing::info!(
                            policy = %triggered.policy_name,
                            patterns = ?result.matched_types,
                            blocked = result.should_block,
                            "applied request-side redaction"
                        );
                        if result.should_block {
                            // Block mode: reject the request and tell the caller which PII was found
                            return Err(AppError::ContentBlocked {
                                reason: format!(
                                    "Request contains PII that violates policy '{}'",
                                    triggered.policy_name
                                ),
                                details: Some(serde_json::json!({
                                    "policy": triggered.policy_name,
                                    "detected_pii": result.matched_types,
                                    "action": "Remove sensitive data and retry"
                                })),
                            });
                        }
                        redacted_by_policy.extend(result.matched_types);
                    }
                }
            }

            // ── Transform ──
            Action::Transform { operations } => {
                for op in operations {
                    if let Some(ref mut body_val) = parsed_body {
                        middleware::redact::apply_transform(body_val, &mut header_mutations, op);
                    } else {
                        // No body, but we can still do header transforms
                        let mut empty = serde_json::Value::Null;
                        middleware::redact::apply_transform(&mut empty, &mut header_mutations, op);
                    }
                }
                tracing::info!(
                    policy = %triggered.policy_name,
                    ops = operations.len(),
                    "applied transform operations"
                );
            }


            // ── ConditionalRoute (request-side) ──
            Action::ConditionalRoute { branches, fallback } => {
                let req_body_val = parsed_body.clone().unwrap_or(serde_json::Value::Null);
                let matched_target = proxy::smart_router::evaluate_conditional_route_branches(
                    branches, &req_body_val, &headers,
                );
                let target = matched_target
                    .or_else(|| fallback.clone())
                    .ok_or_else(|| AppError::PolicyDenied {
                        policy: triggered.policy_name.clone(),
                        reason: "no conditional route branch matched and no fallback configured".to_string(),
                    })?;
                // Override upstream URL and model the same way DynamicRoute does
                dynamic_upstream_override = Some(target.upstream_url.clone());
                if let Some(ref mut body_val) = parsed_body {
                    if let Some(obj) = body_val.as_object_mut() {
                        obj.insert("model".into(), serde_json::json!(target.model));
                    }
                }
                tracing::info!(
                    policy = %triggered.policy_name,
                    model = %target.model,
                    upstream = %target.upstream_url,
                    "conditional_route: matched branch"
                );
            }

            // ValidateSchema only applies post-flight (response phase) — skip in pre-flight
            Action::ValidateSchema { .. } => {
                tracing::debug!(
                    policy = %triggered.policy_name,
                    "ValidateSchema is a response-phase action, skipping in pre-flight"
                );
            }

            // ExternalGuardrail: call external vendor API with a hard deadline, deny or log on violation
            Action::ExternalGuardrail { vendor, endpoint, api_key_env, threshold, on_fail } => {
                let text = parsed_body.as_ref()
                    .map(|v| v.to_string())
                    .unwrap_or_default();
                // check_with_timeout wraps the vendor call in a tokio::time::timeout (default 5s,
                // configurable via AILINK_GUARDRAIL_TIMEOUT_SECS). On expiry it returns Err(...)
                // which falls through to the fail-open branch below — capping worst-case latency.
                match middleware::external_guardrail::check_with_timeout(
                    vendor, endpoint, api_key_env.as_deref(), *threshold, &text
                ).await {
                    Ok(result) if result.blocked => {
                        tracing::warn!(
                            policy = %triggered.policy_name,
                            vendor = ?vendor,
                            label = %result.label,
                            score = %result.score,
                            "ExternalGuardrail: violation detected"
                        );
                        if on_fail != "log" {
                            let mut audit = base_audit(
                                request_id, token.project_id, &token.id, agent_name,
                                method.as_str(), &path, &token.upstream_url, &policies,
                                false, None, None,
                                user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                                session_id.clone(), parent_span_id.clone(),
                                custom_properties.clone(),
                            );
                            audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
                                policy: triggered.policy_name.clone(),
                                reason: format!("external_guardrail({:?}): {}", vendor, result.label),
                            });
                            audit.response_latency_ms = start.elapsed().as_millis() as u64;
                            audit.emit(&state);
                            return Err(AppError::PolicyDenied {
                                policy: triggered.policy_name.clone(),
                                reason: format!("blocked by external guardrail: {}", result.label),
                            });
                        }
                    }
                    Ok(_) => {} // clean
                    Err(e) => {
                        tracing::error!(
                            policy = %triggered.policy_name,
                            vendor = ?vendor,
                            error = %e,
                            "ExternalGuardrail: vendor call failed (fail-open)"
                        );
                    }
                }
            }

            // ── ToolScope: per-tool whitelist/blacklist RBAC ──
            Action::ToolScope { allowed_tools, blocked_tools, deny_message } => {
                let tool_names = middleware::engine::extract_tool_names(parsed_body.as_ref());
                if !tool_names.is_empty() {
                    if let Err(reason) = middleware::engine::evaluate_tool_scope(
                        &tool_names, allowed_tools, blocked_tools, deny_message,
                    ) {
                        tracing::warn!(
                            policy = %triggered.policy_name,
                            tools = ?tool_names,
                            reason = %reason,
                            "ToolScope: tool denied by policy"
                        );
                        let mut audit = base_audit(
                            request_id, token.project_id, &token.id, agent_name,
                            method.as_str(), &path, &token.upstream_url, &policies,
                            false, None, None,
                            user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                            session_id.clone(), parent_span_id.clone(),
                            custom_properties.clone(),
                        );
                        audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
                            policy: triggered.policy_name.clone(),
                            reason: reason.clone(),
                        });
                        audit.response_latency_ms = start.elapsed().as_millis() as u64;
                        audit.emit(&state);
                        return Err(AppError::PolicyDenied {
                            policy: triggered.policy_name.clone(),
                            reason,
                        });
                    }
                }
            }
        }
    }
    if !policy_rate_limited && state.config.default_rate_limit > 0 {
        let rl_key = format!("rl:default:tok:{}", token.id);
        let count = state
            .cache
            .increment(&rl_key, state.config.default_rate_limit_window)
            .await
            .map_err(AppError::Internal)?;

        if count > state.config.default_rate_limit {
            tracing::warn!(
                token_id = %token.id,
                count = count,
                limit = state.config.default_rate_limit,
                window_secs = state.config.default_rate_limit_window,
                "default rate limit exceeded"
            );
            let mut audit = base_audit(
                request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                &token.upstream_url, &policies, false, None, None,
                user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                session_id.clone(), parent_span_id.clone(),
                custom_properties.clone(),
            );
            audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
                policy: "DefaultRateLimit".to_string(),
                reason: format!(
                    "default rate limit of {} req/{}s exceeded",
                    state.config.default_rate_limit, state.config.default_rate_limit_window
                ),
            });
            audit.response_latency_ms = start.elapsed().as_millis() as u64;
            audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
            audit.emit(&state);
            return Err(AppError::RateLimitExceeded);
        }
    }

    // -- 3.5 Check Spend Cap --
    if let Err(e) = middleware::spend::check_spend_cap(&state.cache, state.db.pool(), &token.id).await {
        let mut audit = base_audit(
            request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
            &token.upstream_url, &policies, false, None, None,
            user_id.clone(), tenant_id.clone(), external_request_id.clone(),
            session_id.clone(), parent_span_id.clone(),
            custom_properties.clone(),
        );
        audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
            policy: "SpendCap".to_string(),
            reason: e.to_string(),
        });
        audit.response_latency_ms = start.elapsed().as_millis() as u64;
        audit.emit(&state);

        // Webhook dispatch
        let webhook_event = crate::notification::webhook::WebhookEvent::spend_cap_exceeded(
            &token.id,
            &token.name,
            &token.project_id.to_string(),
            &e.to_string(),
        );
        let webhook_urls = state.config.webhook_urls.clone();
        state.webhook.dispatch(&webhook_urls, webhook_event).await;

        return Err(AppError::SpendCapReached {
            message: format!("Spend cap reached (USD): {}. Check your limits at the AILink dashboard.", e),
        });
    }

    // -- 3.5b Project-Level Hard Cap --
    // Uses a 60s Redis cache to avoid a DB round-trip on every request.
    if crate::jobs::budget_checker::is_project_over_hard_cap_cached(
        state.db.pool(),
        &state.cache,
        token.project_id,
    ).await {
        let mut audit = base_audit(
            request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
            &token.upstream_url, &policies, false, None, None,
            user_id.clone(), tenant_id.clone(), external_request_id.clone(),
            session_id.clone(), parent_span_id.clone(),
            custom_properties.clone(),
        );
        audit.policy_result = Some(crate::models::audit::PolicyResult::Deny {
            policy: "ProjectBudgetCap".to_string(),
            reason: "Project hard spend cap exceeded".to_string(),
        });
        audit.response_latency_ms = start.elapsed().as_millis() as u64;
        audit.emit(&state);

        return Err(AppError::SpendCapReached {
            message: "Project spending limit reached. Contact your administrator or review limits at the AILink dashboard.".to_string(),
        });
    }

    // -- 3.6 Session Lifecycle Guard --
    // If this request has a session_id, auto-create the session on first use,
    // then enforce status (reject if paused/completed) and session-level spend cap.
    if let Some(ref sid) = session_id {
        // Upsert: auto-create session on first request, or touch updated_at
        match state.db.upsert_session(sid, token.project_id, Uuid::parse_str(&token.id).ok(), None).await {
            Ok(entity) => {
                // Reject requests against paused or completed sessions
                if entity.status != "active" {
                    tracing::info!(
                        session_id = %sid,
                        status = %entity.status,
                        "Session lifecycle: request rejected (non-active session)"
                    );
                    return Err(AppError::PolicyDenied {
                        policy: "SessionLifecycle".to_string(),
                        reason: format!("Session '{}' is {} — cannot accept new requests", sid, entity.status),
                    });
                }

                // Check session-level spend cap
                if let Some(cap) = entity.spend_cap_usd {
                    if entity.total_cost_usd >= cap {
                        tracing::info!(
                            session_id = %sid,
                            total = %entity.total_cost_usd,
                            cap = %cap,
                            "Session spend cap exceeded"
                        );
                        return Err(AppError::SpendCapReached {
                            message: format!("Session '{}' has exceeded its spend cap ({} USD)", sid, cap),
                        });
                    }
                }
            }
            Err(e) => {
                // Fail open: log error but don't block the request
                tracing::warn!(
                    session_id = %sid,
                    error = %e,
                    "Session upsert failed (fail-open)"
                );
            }
        }
    }

    // -- 3.7 Anomaly Detection (non-blocking, informational) --
    // Record this request's timestamp in a Redis sliding window and check
    // if the token's velocity exceeds 3σ from its rolling baseline.
    {
        let anomaly_config = middleware::anomaly::AnomalyConfig::default();
        let mut redis_conn = state.cache.redis();
        match middleware::anomaly::record_and_check(&mut redis_conn, &token.id.to_string(), &anomaly_config).await {
            Ok(result) if result.is_anomalous => {
                tracing::warn!(
                    token_id = %token.id,
                    velocity = result.current_velocity,
                    mean = result.baseline_mean,
                    threshold = result.threshold,
                    "Anomaly detected: velocity spike for token"
                );
                // Fire webhook (non-blocking)
                let webhook_event = crate::notification::webhook::WebhookEvent::anomaly_detected(
                    &token.id.to_string(),
                    &token.name,
                    &token.project_id.to_string(),
                    result.current_velocity,
                    result.baseline_mean,
                    result.threshold,
                );
                let webhook_urls = state.config.webhook_urls.clone();
                state.webhook.dispatch(&webhook_urls, webhook_event).await;
                // NOTE: anomaly detection is informational — we do NOT block the request.
                // Use rate limiting policies for enforcement.
            }
            Ok(_) => {} // Normal velocity
            Err(e) => {
                tracing::debug!(error = %e, "Anomaly check failed (non-critical, proceeding)");
            }
        }
    }

    // -- 3.8 Handle HITL --
    if hitl_required {
        let hitl_start = Instant::now();

        // Create approval request
        let summary = serde_json::json!({
            "method": method.to_string(),
            "path": path,
            "agent": agent_name,
            "upstream": token.upstream_url,
            "body_preview": parsed_body.as_ref().map(|b| {
                // SEC: use char-based truncation to avoid panicking on multi-byte UTF-8 boundaries.
                // Limit raised to 2000 chars so HITL reviewers see enough context.
                let s = b.to_string();
                let char_count = s.chars().count();
                if char_count > 2000 {
                    let truncated: String = s.chars().take(2000).collect();
                    format!("{}…", truncated)
                } else {
                    s
                }
            }),
        });

        // Expiry: 10 minutes (can be overridden by policy timeout later)
        let expires_at = chrono::Utc::now() + chrono::Duration::minutes(10);

        let approval_id = state
            .db
            .create_approval_request(
                &token.id,
                token.project_id,
                idempotency_key.clone(),
                summary.clone(),
                expires_at,
            )
            .await
            .map_err(AppError::Internal)?;

        // Phase 5: Emit notifications
        // 1. Dashboard Notification
        let state_clone = state.clone();
        let project_id = token.project_id;
        let title = "Approval Required".to_string();
        let body_text = format!("Request to {} requires approval.", path);
        let metadata = serde_json::json!({ "approval_id": approval_id });
        tokio::spawn(async move {
            let _ = state_clone
                .db
                .create_notification(
                    project_id,
                    "approval_needed",
                    &title,
                    Some(&body_text),
                    Some(metadata),
                )
                .await;
        });

        // 2. Webhook Notification (includes full request body for app parsing)
        let webhook_event = crate::notification::webhook::WebhookEvent::approval_requested(
            &token.id,
            &token.name,
            &token.project_id.to_string(),
            &approval_id.to_string(),
            method.as_str(),
            &path,
            &token.upstream_url,
            parsed_body.clone(),
        );
        let webhook_urls = state.config.webhook_urls.clone();
        let webhook_notifier = state.webhook.clone();
        tokio::spawn(async move {
            webhook_notifier.dispatch(&webhook_urls, webhook_event).await;
        });

        // 3. Send Slack notification (async)
        let notifier = state.notifier.clone();
        let app_id = approval_id;
        let summary_clone = summary.clone();
        let expires_at_clone = expires_at;
        tokio::spawn(async move {
            if let Err(e) = notifier
                .send_approval_request(&app_id, &summary_clone, &expires_at_clone)
                .await
            {
                tracing::error!("Failed to send approval notification: {}", e);
            }
        });

        let timeout_secs = middleware::policy::parse_window_secs(&hitl_timeout_str).unwrap_or(1800); // default 30m

        // ── HITL: Dedicated-connection BLPOP for instant approval delivery ──
        // We create a dedicated Redis connection (not the shared ConnectionManager)
        // so BLPOP blocks only this connection without affecting the connection pool.
        // This gives us sub-millisecond notification latency vs the old 500ms LPOP polling.
        let hitl_key = format!("hitl:decision:{}", approval_id);
        #[allow(unused_assignments)]
        let mut approved = false;
        let mut decision_opt: Option<String> = None;

        // Try dedicated BLPOP first, fall back to LPOP polling if connection fails
        let blpop_timeout = timeout_secs.min(1800) as f64; // Redis BLPOP timeout in seconds
        let blpop_result: Result<Option<String>, ()> = async {
            // Open a fresh, dedicated connection for the blocking call
            let redis_url = std::env::var("REDIS_URL")
                .unwrap_or_else(|_| "redis://127.0.0.1:6379".into());
            let client = redis::Client::open(redis_url.as_str()).map_err(|e| {
                tracing::warn!("HITL: failed to create dedicated Redis client: {}", e);
            })?;
            let mut conn = client.get_multiplexed_async_connection().await.map_err(|e| {
                tracing::warn!("HITL: failed to open dedicated Redis connection: {}", e);
            })?;

            // BLPOP blocks until a value is pushed or timeout expires.
            // Returns Option<(key, value)> tuple.
            let result: redis::RedisResult<Option<(String, String)>> = redis::cmd("BLPOP")
                .arg(&hitl_key)
                .arg(blpop_timeout)
                .query_async(&mut conn)
                .await;

            match result {
                Ok(Some((_key, value))) => Ok(Some(value)),
                Ok(None) => Ok(None), // timeout expired
                Err(e) => {
                    tracing::warn!("HITL BLPOP failed: {}", e);
                    Err(())
                }
            }
        }.await;

        match blpop_result {
            Ok(Some(value)) => {
                decision_opt = Some(value);
            }
            Ok(None) => {
                // BLPOP timed out — no decision received
            }
            Err(()) => {
                // Redis failed — fall back to LPOP polling loop
                tracing::info!("HITL: falling back to LPOP polling");
                let mut redis_conn = state.cache.redis();
                let start_wait = std::time::Instant::now();
                let timeout_duration = std::time::Duration::from_secs(timeout_secs as u64);

                while start_wait.elapsed() < timeout_duration {
                    let lpop_result: redis::RedisResult<Option<String>> =
                        redis::AsyncCommands::lpop(&mut redis_conn, &hitl_key, None).await;

                    match lpop_result {
                        Ok(Some(value)) => {
                            decision_opt = Some(value);
                            break;
                        }
                        Ok(None) => {
                            tokio::time::sleep(std::time::Duration::from_millis(500)).await;
                        }
                        Err(e) => {
                            tracing::warn!("HITL LPOP fallback also failed: {}", e);
                            break;
                        }
                    }
                }
            }
        }

        let decision = match decision_opt {
            Some(value) => value,
            None => {
                // All Redis paths exhausted — final DB check
                state.db.get_approval_status(approval_id).await
                    .map_err(AppError::Internal)?
            }
        };

        match decision.as_str() {
            "approved" => {
                approved = true;
                hitl_decision = Some("approved".to_string());
            }
            "rejected" => {
                hitl_decision = Some("rejected".to_string());
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &token.upstream_url, &policies, true, hitl_decision.clone(),
                    Some(hitl_start.elapsed().as_millis() as i32),
                    user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                    session_id.clone(), parent_span_id.clone(),
                    custom_properties.clone(),
                );
                audit.policy_result = Some(crate::models::audit::PolicyResult::HitlRejected);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations.clone()) };
                audit.emit(&state);
                return Err(AppError::ApprovalRejected);
            }
            "expired" | _ => {
                hitl_decision = Some("expired".to_string());
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &token.upstream_url, &policies, true, hitl_decision.clone(),
                    Some(hitl_start.elapsed().as_millis() as i32),
                    user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                    session_id.clone(), parent_span_id.clone(),
                    custom_properties.clone(),
                );
                audit.policy_result = Some(crate::models::audit::PolicyResult::HitlTimeout);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations.clone()) };
                audit.emit(&state);
                return Err(AppError::ApprovalTimeout);
            }
        }

        if !approved {
            hitl_decision = Some("timeout".to_string());
            let mut audit = base_audit(
                request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                &token.upstream_url, &policies, true, hitl_decision.clone(),
                Some(hitl_start.elapsed().as_millis() as i32),
                user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                session_id.clone(), parent_span_id.clone(),
                custom_properties.clone(),
            );
            audit.policy_result = Some(crate::models::audit::PolicyResult::HitlTimeout);
            audit.response_latency_ms = start.elapsed().as_millis() as u64;
            audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations.clone()) };
            audit.emit(&state);
            return Err(AppError::ApprovalTimeout);
        }

        hitl_latency_ms = Some(hitl_start.elapsed().as_millis() as i32);
    }

    // -- 4. Resolve credential + upstream URL --
    // Service Registry: if path starts with /v1/proxy/services/{name}/...,
    // dynamically resolve the service and use its credential + base_url.
    let service_prefix = "/v1/proxy/services/";
    let (effective_credential_id, effective_upstream_url, effective_path) =
        if path.starts_with(service_prefix) {
            let rest = &path[service_prefix.len()..]; // "stripe/v1/charges"
            let (svc_name, remaining_path) = match rest.find('/') {
                Some(pos) => (&rest[..pos], &rest[pos..]),         // ("stripe", "/v1/charges")
                None => (rest, "/"),                                // ("stripe", "/")
            };

            let service = state
                .db
                .get_service_by_name(token.project_id, svc_name)
                .await
                .map_err(AppError::Internal)?
                .ok_or_else(|| {
                    AppError::Upstream(format!("Service not found: {}", svc_name))
                })?;

            // Service may or may not have a credential — passthrough is allowed
            (service.credential_id, service.base_url.clone(), remaining_path.to_string())
        } else {
            // Loadbalancer: use weighted routing. Fallback to upstream_url if JSONB is empty.
            let mut lb_upstreams = proxy::loadbalancer::parse_upstreams(token.upstreams.as_ref());

            if lb_upstreams.is_empty() {
                // Legacy/Single upstream mode: create a single target from upstream_url
                lb_upstreams.push(proxy::loadbalancer::UpstreamTarget {
                    url: token.upstream_url.clone(),
                    weight: 100,
                    priority: 1,
                    credential_id: None, // Will fallback to token.credential_id below
                });
            }

            // DEBUG LOGGING
            tracing::info!(token_id = %token.id, upstream_count = lb_upstreams.len(), "Calling LB select");

            // Always route through LB to ensure health tracking
            if let Some(idx) = state.lb.select(&token.id, &lb_upstreams, &cb_config) {
                let target = &lb_upstreams[idx];
                tracing::info!(token_id = %token.id, selected_url = %target.url, "LB selected target");
                // Use target-specific credential if set, otherwise token default
                let effective_cred_id = target.credential_id.or(token.credential_id);
                (effective_cred_id, target.url.clone(), path.clone())
            } else {
                // All upstreams unhealthy — fall back to primary as last resort
                tracing::error!("all upstreams unhealthy, falling back to primary");
                (token.credential_id, token.upstream_url.clone(), path.clone())
            }
        };

    // -- 4.1 Credential injection vs passthrough --
    // If credential_id is Some, decrypt from vault and inject.
    // If None, operate in passthrough mode: forward X-Real-Authorization from the agent.
    struct InjectedCredential {
        key: String,
        mode: String,
        header: String,
    }

    let injected_cred = if let Some(cred_id) = effective_credential_id {
        let (real_key, _provider, injection_mode, injection_header) = state
            .vault
            .retrieve(&cred_id.to_string())
            .await
            .map_err(AppError::Internal)?;
        Some(InjectedCredential {
            key: real_key,
            mode: injection_mode,
            header: injection_header,
        })
    } else {
        None // Passthrough mode
    };

    // -- 5. Build upstream request --
    let upstream_url = proxy::transform::rewrite_url(&effective_upstream_url, &effective_path);

    // ── Response Cache: check for cache hit BEFORE upstream call ──
    let skip_cache = proxy::response_cache::should_skip_cache(&headers, parsed_body.as_ref())
        || is_streaming_req
        || method != Method::POST;
    let cache_key = if !skip_cache {
        parsed_body.as_ref().and_then(|b| {
            proxy::response_cache::compute_cache_key(&token.id, b)
        })
    } else {
        None
    };

    if let Some(ref key) = cache_key {
        if let Some(cached) = proxy::response_cache::get_cached(&state.cache, key).await {
            tracing::info!(cache_key = %key, "response cache HIT");
            let mut audit = base_audit(
                request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
                user_id, tenant_id, external_request_id,
                session_id, parent_span_id,
                custom_properties.clone(),
            );
            audit.policy_result = Some(crate::models::audit::PolicyResult::Allow);
            audit.upstream_status = Some(cached.status);
            audit.response_latency_ms = start.elapsed().as_millis() as u64;
            audit.cache_hit = true;
            audit.model = cached.model;
            audit.prompt_tokens = cached.prompt_tokens;
            audit.completion_tokens = cached.completion_tokens;
            audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
            audit.emit(&state);

            let axum_status = StatusCode::from_u16(cached.status)
                .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);
            return Response::builder()
                .status(axum_status)
                .header("content-type", cached.content_type)
                .header("x-ailink-cache", "HIT")
                .body(Body::from(cached.body))
                .map_err(|e| AppError::Internal(anyhow::anyhow!("cached response build failed: {}", e)));
        }
    }

    // ── Universal Model Router: translate request for non-OpenAI providers ──
    let detected_model = parsed_body.as_ref()
        .and_then(|b| b.get("model"))
        .and_then(|m| m.as_str())
        .unwrap_or("")
        .to_string();
    let detected_provider = if !detected_model.is_empty() {
        proxy::model_router::detect_provider(&detected_model, &effective_upstream_url)
    } else {
        proxy::model_router::Provider::Unknown
    };

    // Translate request body if needed (OpenAI → Anthropic/Gemini)
    let router_translated = if let Some(ref body_val) = parsed_body {
        proxy::model_router::translate_request(detected_provider, body_val)
    } else {
        None
    };

    // Rewrite upstream URL for the target provider.
    // Gemini uses different endpoints for streaming vs non-streaming.
    // If DynamicRoute/ConditionalRoute selected a different upstream, use that instead.
    let upstream_url = if let Some(dyn_url) = dynamic_upstream_override {
        // DynamicRoute override takes precedence.
        // Re-detect provider from the new upstream URL + the DynamicRoute-selected model.
        let dyn_model = parsed_body.as_ref()
            .and_then(|b| b.get("model"))
            .and_then(|m| m.as_str())
            .unwrap_or(&detected_model);
        let dyn_provider = proxy::model_router::detect_provider(dyn_model, &dyn_url);

        if dyn_provider != proxy::model_router::Provider::OpenAI
            && dyn_provider != proxy::model_router::Provider::Unknown
        {
            // Non-OpenAI provider: let model_router rewrite the URL (e.g. Gemini paths)
            proxy::model_router::rewrite_upstream_url(dyn_provider, &dyn_url, dyn_model, is_streaming_req)
        } else {
            // OpenAI-compatible: append the original request path to the override base URL
            proxy::transform::rewrite_url(&dyn_url, &effective_path)
        }
    } else if detected_provider != proxy::model_router::Provider::OpenAI
        && detected_provider != proxy::model_router::Provider::Unknown
    {
        proxy::model_router::rewrite_upstream_url(detected_provider, &upstream_url, &detected_model, is_streaming_req)
    } else {
        upstream_url
    };

    // Use modified body if overrides were applied, otherwise original
    let final_body = if let Some(ref translated) = router_translated {
        // Model router translated the body — use translated version
        serde_json::to_vec(translated).unwrap_or_else(|_| body.to_vec())
    } else if let Some(ref modified) = parsed_body {
        // Check if body was modified by Override action
        serde_json::to_vec(modified).unwrap_or_else(|_| body.to_vec())
    } else {
        body.to_vec()
    };

    // Build upstream headers
    let mut upstream_headers = reqwest::header::HeaderMap::new();

    // Track injection mode for audit logging
    let _injection_mode_str: String;

    if let Some(ref cred) = injected_cred {
        // === Credential injection mode ===
        _injection_mode_str = cred.mode.clone();

        let header_name: reqwest::header::HeaderName = cred.header.parse().map_err(|_| {
            AppError::Internal(anyhow::anyhow!(
                "invalid injection_header: {}",
                cred.header
            ))
        })?;

        match cred.mode.as_str() {
            "basic" => {
                use base64::Engine;
                let encoded = base64::engine::general_purpose::STANDARD.encode(&cred.key);
                upstream_headers.insert(
                    header_name,
                    reqwest::header::HeaderValue::from_str(&format!("Basic {}", encoded))
                        .map_err(|_| AppError::Internal(anyhow::anyhow!("invalid key format")))?,
                );
            }
            "header" => {
                upstream_headers.insert(
                    header_name,
                    reqwest::header::HeaderValue::from_str(&cred.key)
                        .map_err(|_| AppError::Internal(anyhow::anyhow!("invalid key format")))?,
                );
            }
            "query" => {
                // Don't inject a header — we'll append to the URL below
            }
            _ => {
                upstream_headers.insert(
                    header_name,
                    reqwest::header::HeaderValue::from_str(&format!("Bearer {}", cred.key))
                        .map_err(|_| AppError::Internal(anyhow::anyhow!("invalid key format")))?,
                );
            }
        }
    } else {
        // === Passthrough mode ===
        // Forward the agent's own authorization via X-Real-Authorization or X-Upstream-Authorization
        _injection_mode_str = "passthrough".to_string();

        let real_auth = headers
            .get("X-Real-Authorization")
            .or_else(|| headers.get("X-Upstream-Authorization"))
            .and_then(|v| v.to_str().ok());

        if let Some(auth_value) = real_auth {
            upstream_headers.insert(
                "authorization",
                reqwest::header::HeaderValue::from_str(auth_value)
                    .map_err(|_| AppError::Internal(anyhow::anyhow!("invalid auth header in X-Real-Authorization")))?,
            );
        }
        // If no real auth header provided, forward without Authorization.
        // This supports upstream APIs that don't require auth (e.g., public endpoints).
    }

    upstream_headers.insert(
        "Content-Type",
        reqwest::header::HeaderValue::from_str(&original_content_type).unwrap_or(
            reqwest::header::HeaderValue::from_static("application/json"),
        ),
    );

    // ── Provider-specific required header injection ─────────────────────────
    // Injects headers that the upstream API mandates (e.g. anthropic-version).
    // Uses entry().or_insert() so policy-level headers always win.
    proxy::model_router::inject_provider_headers(
        detected_provider,
        &mut upstream_headers,
        is_streaming_req,
    );

    // Apply transform header mutations (SetHeader / RemoveHeader)
    for name in &header_mutations.removals {
        if let Ok(header_name) = name.parse::<reqwest::header::HeaderName>() {
            upstream_headers.remove(header_name);
        }
    }
    for (name, value) in &header_mutations.inserts {
        if let (Ok(header_name), Ok(header_value)) = (
            name.parse::<reqwest::header::HeaderName>(),
            reqwest::header::HeaderValue::from_str(value),
        ) {
            upstream_headers.insert(header_name, header_value);
        }
    }

    // W3C Trace Context propagation: forward a child traceparent to the upstream.
    // We use the incoming trace_id (if any) to maintain the same trace, but generate
    // a new span_id from our request_id so the gateway hop is visible in traces.
    let gateway_span_id = &request_id.to_string().replace('-', "")[..16]; // 16 hex chars
    let outbound_traceparent = if let Some(ref trace_id) = w3c_trace_id {
        // A traceparent was received — propagate the same trace with our span as parent
        format!("00-{}-{}-01", trace_id, gateway_span_id)
    } else {
        // No incoming traceparent — start a new one using req_id as trace_id
        let trace_hex = request_id.to_string().replace('-', "");
        format!("00-{}-{}-01", trace_hex, gateway_span_id)
    };
    if let Ok(hv) = reqwest::header::HeaderValue::from_str(&outbound_traceparent) {
        upstream_headers.insert("traceparent", hv);
        tracing::debug!(
            traceparent = %outbound_traceparent,
            req_id = %request_id,
            "forwarding traceparent to upstream"
        );
    }
    // Also forward tracestate if present (preserves vendor-specific data)
    if let Some(ts) = headers.get("tracestate").and_then(|v| v.to_str().ok()) {
        if let Ok(hv) = reqwest::header::HeaderValue::from_str(ts) {
            upstream_headers.insert("tracestate", hv);
        }
    }

    // Forward standard safe headers (required by strict APIs like GitHub)
    if let Some(ua) = headers.get(reqwest::header::USER_AGENT) {
        upstream_headers.insert(reqwest::header::USER_AGENT, ua.clone());
    } else {
        // Fallback User-Agent if none provided by client
        upstream_headers.insert(reqwest::header::USER_AGENT, reqwest::header::HeaderValue::from_static("AILink-Gateway/1.0"));
    }
    
    if let Some(accept) = headers.get(reqwest::header::ACCEPT) {
        upstream_headers.insert(reqwest::header::ACCEPT, accept.clone());
    }

    // Convert method Axum -> Reqwest
    let reqwest_method = reqwest::Method::from_bytes(method.as_str().as_bytes())
        .map_err(|e| AppError::Internal(anyhow::anyhow!("invalid method: {}", e)))?;

    // Handle query param injection by appending to the URL (only in credential injection mode)
    let final_upstream_url = if let Some(ref cred) = injected_cred {
        if cred.mode == "query" {
            let separator = if upstream_url.contains('?') { "&" } else { "?" };
            format!(
                "{}{}{}={}",
                upstream_url,
                separator,
                cred.header,
                urlencoding::encode(&cred.key)
            )
        } else {
            upstream_url.clone()
        }
    } else {
        upstream_url.clone()
    };

    // Zero the decrypted key from memory (if credential was injected)
    if let Some(mut cred) = injected_cred {
        use zeroize::Zeroize;
        cred.key.zeroize();
    }

    // -- 5.1 Resolve Retry Config --
    // Use the first policy that specifies a retry config, or default
    let mut retry_config = policies
        .iter()
        .find_map(|p| p.retry.clone())
        .unwrap_or_default();

    // P1.7: Idempotency safety guard — skip retries for mutating requests without an idempotency key.
    // Retrying POST/PUT/PATCH without idempotency guarantees can cause duplicate charges/operations.
    let is_mutating = matches!(method, Method::POST | Method::PUT | Method::PATCH);
    let has_idempotency_key = headers.contains_key("idempotency-key")
        || headers.contains_key("x-idempotency-key");
    let idempotency_warning = if is_mutating && !has_idempotency_key && retry_config.max_retries > 0 {
        retry_config.max_retries = 0; // Disable retries for safety
        Some("POST/PUT/PATCH request not retried (no Idempotency-Key header). Add 'Idempotency-Key: <unique-id>' to enable safe retries.")
    } else {
        None
    };

    // Forward with explicit timeout safety — scale for retries
    // For streaming requests, use forward_raw (no retry, returns raw response for piping)
    let safety_secs = 65 + (retry_config.max_retries as u64 * (retry_config.max_backoff_ms / 1000 + 65));
    let upstream_resp = if is_streaming_req {
        // Streaming: no retry, direct connection
        match tokio::time::timeout(
            Duration::from_secs(safety_secs),
            state.upstream_client.forward_raw(
                reqwest_method,
                &final_upstream_url,
                upstream_headers,
                bytes::Bytes::from(final_body),
            ),
        )
        .await
        {
            Ok(Ok(res)) => {
                state.lb.mark_healthy(&token.id, &final_upstream_url);
                res
            }
            Ok(Err(e)) => {
                tracing::error!("Upstream streaming request failed: {}", e);
                state.lb.mark_failed(&token.id, &final_upstream_url, &cb_config);
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
                    user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                    session_id.clone(), parent_span_id.clone(),
                    custom_properties.clone(),
                );
                audit.upstream_status = Some(502);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.is_streaming = true;
                audit.emit(&state);
                return Err(e);
            }
            Err(_) => {
                tracing::error!("Upstream streaming request timed out (safety net)");
                state.lb.mark_failed(&token.id, &final_upstream_url, &cb_config);
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
                    user_id, tenant_id, external_request_id,
                    session_id, parent_span_id,
                    custom_properties.clone(),
                );
                audit.upstream_status = Some(504);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.is_streaming = true;
                audit.emit(&state);
                return Err(AppError::Upstream("Upstream streaming request timed out".to_string()));
            }
        }
    } else {
        match tokio::time::timeout(
            Duration::from_secs(safety_secs),
            state.upstream_client.forward(
                reqwest_method,
                &final_upstream_url,
                upstream_headers,
                bytes::Bytes::from(final_body),
                &retry_config,
            ),
        )
        .await
        {
            Ok(Ok(res)) => {
                // Loadbalancer: mark upstream as healthy
                state.lb.mark_healthy(&token.id, &final_upstream_url);
                res
            }
            Ok(Err(e)) => {
                tracing::error!("Upstream request failed: {}", e);
                // Loadbalancer: mark upstream as failed
                state.lb.mark_failed(&token.id, &final_upstream_url, &cb_config);
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
                    user_id.clone(), tenant_id.clone(), external_request_id.clone(),
                    session_id.clone(), parent_span_id.clone(),
                    custom_properties.clone(),
                );
                audit.policy_result = Some(if hitl_required {
                    crate::models::audit::PolicyResult::HitlApproved
                } else {
                    crate::models::audit::PolicyResult::Allow
                });
                audit.upstream_status = Some(502);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
                audit.is_streaming = is_streaming_req;
                audit.emit(&state);
                return Err(e);
            }
            Err(_) => {
                tracing::error!("Upstream request timed out (safety net)");
                // Loadbalancer: mark upstream as failed
                state.lb.mark_failed(&token.id, &final_upstream_url, &cb_config);
                let mut audit = base_audit(
                    request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
                    &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
                    user_id, tenant_id, external_request_id,
                    session_id, parent_span_id,
                    custom_properties.clone(),
                );
                audit.policy_result = Some(if hitl_required {
                    crate::models::audit::PolicyResult::HitlApproved
                } else {
                    crate::models::audit::PolicyResult::Allow
                });
                audit.upstream_status = Some(504);
                audit.response_latency_ms = start.elapsed().as_millis() as u64;
                audit.shadow_violations = if shadow_violations.is_empty() { None } else { Some(shadow_violations) };
                audit.is_streaming = is_streaming_req;
                audit.emit(&state);
                return Err(AppError::Upstream("Upstream request timed out".to_string()));
            }
        }
    };

    let status = upstream_resp.status();
    let resp_headers = upstream_resp.headers().clone();

    // ── STREAMING FAST PATH: zero-copy SSE passthrough ──────────────────────
    // For successful streaming responses, pipe bytes directly to the client.
    // Audit, cost tracking, and sanitization happen in a background task.
    if is_streaming_req && status.is_success() {
        let (stream_body, result_slot) =
            proxy::stream_bridge::tee_sse_stream(upstream_resp, start);

        // Build the SSE response immediately — this starts streaming to the client
        let mut sse_response = axum::response::Response::builder()
            .status(StatusCode::OK)
            .header("content-type", "text/event-stream")
            .header("cache-control", "no-cache")
            .header("x-accel-buffering", "no") // Disable nginx buffering
            .body(stream_body)
            .map_err(|e| AppError::Internal(anyhow::anyhow!("stream response build: {}", e)))?;

        // Forward safe upstream headers (skip hop-by-hop headers)
        for (key, value) in resp_headers.iter() {
            let name_str = key.as_str();
            if matches!(name_str, "content-length" | "transfer-encoding" | "connection") {
                continue;
            }
            if let Ok(name) = axum::http::HeaderName::from_bytes(name_str.as_bytes()) {
                if let Ok(val) = axum::http::HeaderValue::from_bytes(value.as_bytes()) {
                    sse_response.headers_mut().insert(name, val);
                }
            }
        }

        // Spawn background task: wait for stream to finish, then audit + cost
        let state_bg = state.clone();
        // Extract needed token fields (TokenRow doesn't implement Clone)
        let token_bg_id = token.id.clone();
        let token_bg_project_id = token.project_id;
        let token_bg_upstream_url = token.upstream_url.clone();
        let policies_bg = policies.clone();
        let shadow_violations_bg = shadow_violations.clone();
        let upstream_url_bg = upstream_url.clone();
        let path_bg = path.clone();
        let user_id_bg = user_id.clone();
        let tenant_id_bg = tenant_id.clone();
        let ext_req_id_bg = external_request_id.clone();
        let session_id_bg = session_id.clone();
        let session_id_for_spend = session_id.clone();
        let parent_span_id_bg = parent_span_id.clone();

        tokio::spawn(async move {
            // Wait up to 5 minutes for the stream to complete
            let sr = proxy::stream_bridge::wait_for_stream_result(
                &result_slot,
                Duration::from_secs(300),
            ).await;

            let (prompt_tokens, completion_tokens, model_name, finish_reason, tool_calls, ttft_ms) =
                if let Some(ref r) = sr {
                    (r.prompt_tokens, r.completion_tokens, r.model.clone(),
                     r.finish_reason.clone(), r.tool_calls.clone(), r.ttft_ms)
                } else {
                    (None, None, None, None, vec![], None)
                };

            // Cost tracking
            let mut estimated_cost_usd: Option<rust_decimal::Decimal> = None;
            if let (Some(inp), Some(out)) = (prompt_tokens, completion_tokens) {
                let provider = if token_bg_upstream_url.contains("anthropic") {
                    "anthropic"
                } else if token_bg_upstream_url.contains("generativelanguage") {
                    "google"
                } else {
                    "openai"
                };
                let model = model_name.as_deref().unwrap_or("unknown");
                let final_cost = cost::calculate_cost(provider, model, inp, out);
                if !final_cost.is_zero() {
                    estimated_cost_usd = Some(final_cost);
                    let cost_f64 = final_cost.to_f64().unwrap_or(0.0);
                    if let Err(e) = middleware::spend::check_and_increment_spend(
                        &state_bg.cache,
                        state_bg.db.pool(),
                        &token_bg_id,
                        cost_f64,
                    ).await {
                        tracing::error!("Streaming: spend cap exceeded or tracking failed: {}", e);
                    }
                }
            }

            // Sanitize accumulated content for audit log
            let full_content = sr.as_ref().map(|r| r.content.clone()).unwrap_or_default();
            let sanitized_content = middleware::sanitize::sanitize_stream_content(&full_content);

            // Emit audit log
            let mut audit = base_audit(
                request_id, token_bg_project_id, &token_bg_id, agent_name,
                method.as_str(), &path_bg, &upstream_url_bg, &policies_bg,
                hitl_required, hitl_decision, hitl_latency_ms,
                user_id_bg, tenant_id_bg, ext_req_id_bg, session_id_bg, parent_span_id_bg,
                custom_properties.clone(),
            );
            audit.policy_result = Some(if hitl_required {
                crate::models::audit::PolicyResult::HitlApproved
            } else {
                crate::models::audit::PolicyResult::Allow
            });
            audit.upstream_status = Some(200);
            audit.response_latency_ms = start.elapsed().as_millis() as u64;
            audit.is_streaming = true;
            audit.prompt_tokens = prompt_tokens;
            audit.completion_tokens = completion_tokens;
            audit.model = model_name;
            audit.finish_reason = finish_reason;
            // Serialize tool calls to JSON Value for audit storage
            let tool_calls_json = if tool_calls.is_empty() {
                None
            } else {
                serde_json::to_value(&tool_calls).ok()
            };
            audit.tool_calls = tool_calls_json;
            audit.tool_call_count = tool_calls.len() as u16;
            audit.ttft_ms = ttft_ms;
            audit.estimated_cost_usd = estimated_cost_usd;
            audit.fields_redacted = if sanitized_content.redacted_types.is_empty() {
                None
            } else {
                Some(sanitized_content.redacted_types)
            };
            audit.shadow_violations = if shadow_violations_bg.is_empty() { None } else { Some(shadow_violations_bg) };
            audit.emit(&state_bg);

            // -- Session spend increment (streaming) --
            if let Some(ref sid) = session_id_for_spend {
                let cost = estimated_cost_usd.unwrap_or_default();
                let tokens = prompt_tokens.unwrap_or(0) as i64 + completion_tokens.unwrap_or(0) as i64;
                if let Err(e) = state_bg.db.increment_session_spend(sid, token_bg_project_id, cost, tokens).await {
                    tracing::warn!(session_id = %sid, error = %e, "Failed to increment session spend (streaming)");
                }
            }
        });

        return Ok(sse_response);
    }

    // ── NON-STREAMING PATH (buffered) ────────────────────────────────────────
    let resp_body = upstream_resp
        .bytes()
        .await
        .map_err(|e| AppError::Upstream(format!("upstream body read failed: {}", e)))?;

    // -- 5.5 Post-flight policy evaluation --
    let mut resp_body_vec = resp_body.to_vec();

    // ── Universal Model Router: translate SSE streams or JSON responses ──
    if status.is_success() && is_streaming_req {
        // SSE stream: translate entire body from Anthropic/Gemini SSE → OpenAI SSE
        if let Some(translated_sse) = proxy::model_router::translate_sse_body(
            detected_provider,
            &resp_body_vec,
            &detected_model,
        ) {
            resp_body_vec = translated_sse;
        }
    } else if status.is_success() {
        // Non-streaming JSON response: translate as before
        if let Some(parsed) = serde_json::from_slice::<serde_json::Value>(&resp_body_vec).ok() {
            if let Some(translated) = proxy::model_router::translate_response(
                detected_provider,
                &parsed,
                &detected_model,
            ) {
                resp_body_vec = serde_json::to_vec(&translated).unwrap_or(resp_body_vec);
            }
        }
    } else {
        // Error response (4xx/5xx): normalize to OpenAI error format for non-OpenAI providers
        if let Some(normalized) = proxy::model_router::normalize_error_response(
            detected_provider,
            &resp_body_vec,
        ) {
            tracing::debug!(
                provider = ?detected_provider,
                status = %status,
                "normalizing upstream error response to OpenAI format"
            );
            resp_body_vec = serde_json::to_vec(&normalized).unwrap_or(resp_body_vec);
        }
    }


    let parsed_resp_body: Option<serde_json::Value> = serde_json::from_slice(&resp_body_vec).ok();

    // Convert reqwest headers to axum headers for RequestContext
    let axum_resp_headers = {
        let mut h = HeaderMap::new();
        for (key, value) in resp_headers.iter() {
            if let Ok(name) = axum::http::HeaderName::from_bytes(key.as_str().as_bytes()) {
                if let Ok(val) = axum::http::HeaderValue::from_bytes(value.as_bytes()) {
                    h.insert(name, val);
                }
            }
        }
        h
    };

    {
        let project_id_str = token.project_id.to_string();
        let post_ctx = RequestContext {
            method: &method,
            path: &path,
            uri: &uri,
            headers: &headers,
            body: parsed_body.as_ref(),
            body_size: body.len(),
            agent_name: agent_name.as_deref(),
            token_id: &token.id,
            token_name: &token.name,
            project_id: &project_id_str,
            client_ip: client_ip_str.as_deref(),
            response_status: Some(status.as_u16()),
            response_body: parsed_resp_body.as_ref(),
            response_headers: Some(&axum_resp_headers),
            usage: usage_counters,
        };

        let post_outcome = middleware::policy::evaluate_post_flight(&policies, &post_ctx);

        // Execute post-flight actions
        for triggered in &post_outcome.actions {
            match &triggered.action {
                Action::Deny { message, .. } => {
                    tracing::warn!(
                        policy = %triggered.policy_name,
                        "post-flight deny: suppressing unsafe response"
                    );
                    return Err(AppError::PolicyDenied {
                        policy: triggered.policy_name.clone(),
                        reason: message.clone(),
                    });
                }
                Action::Redact { .. } => {
                    if let Some(mut resp_json) = parsed_resp_body.clone() {
                        let result = middleware::redact::apply_redact(
                            &mut resp_json,
                            &triggered.action,
                            false,
                        );
                        if !result.matched_types.is_empty() {
                            tracing::info!(
                                policy = %triggered.policy_name,
                                patterns = ?result.matched_types,
                                "applied response-side redaction"
                            );
                            redacted_by_policy.extend(result.matched_types);
                            // Reserialize the redacted response body
                            if let Ok(new_body) = serde_json::to_vec(&resp_json) {
                                resp_body_vec = new_body;
                            }
                        }
                    }
                }
                Action::Log { level, tags } => match level.as_str() {
                    "error" => {
                        tracing::error!(policy = %triggered.policy_name, tags = ?tags, "post-flight policy log")
                    }
                    "warn" => {
                        tracing::warn!(policy = %triggered.policy_name, tags = ?tags, "post-flight policy log")
                    }
                    _ => {
                        tracing::info!(policy = %triggered.policy_name, tags = ?tags, "post-flight policy log")
                    }
                },
                Action::Tag { key, value } => {
                    tracing::info!(
                        policy = %triggered.policy_name,
                        tag_key = %key, tag_value = %value,
                        "post-flight policy tag"
                    );
                }
                Action::Webhook {
                    url, timeout_ms, ..
                } => {
                    // SEC: SSRF validation for policy-defined webhook URLs
                    if !is_safe_webhook_url(url) {
                        tracing::warn!(
                            policy = %triggered.policy_name,
                            url = %url,
                            "post-flight policy webhook blocked: SSRF protection"
                        );
                    } else {
                        let url = url.clone();
                        let timeout_ms = *timeout_ms;
                        let summary = serde_json::json!({
                            "phase": "post",
                            "policy": triggered.policy_name,
                            "response_status": status.as_u16(),
                        });
                        tokio::spawn(async move {
                            let client = reqwest::Client::new();
                            let _ = client
                                .post(&url)
                                .timeout(Duration::from_millis(timeout_ms))
                                .json(&summary)
                                .send()
                                .await;
                        });
                    }
                }

                // ── ContentFilter (post-flight, response-side) ──
                // Scan the LLM response for jailbreak/harmful content, code injection, etc.
                Action::ContentFilter { .. } => {
                    if let Some(ref resp_json) = parsed_resp_body {
                        let result = middleware::guardrail::check_content(resp_json, &triggered.action);
                        if result.blocked {
                            let reason = result.reason.clone().unwrap_or_else(|| "Output guardrail blocked response".to_string());
                            tracing::warn!(
                                policy = %triggered.policy_name,
                                risk_score = %result.risk_score,
                                patterns = ?result.matched_patterns,
                                "output content filter blocked response"
                            );
                            return Err(AppError::ContentBlocked {
                                reason: reason.clone(),
                                details: Some(serde_json::json!({
                                    "phase": "response",
                                    "policy": triggered.policy_name,
                                    "reason": reason,
                                    "matched_patterns": result.matched_patterns,
                                    "confidence": result.risk_score,
                                })),
                            });
                        } else if !result.matched_patterns.is_empty() {
                            tracing::info!(
                                policy = %triggered.policy_name,
                                risk_score = %result.risk_score,
                                patterns = ?result.matched_patterns,
                                "output content filter: patterns matched but below threshold"
                            );
                        }
                    }
                }

                // ── Transform (post-flight, response-side) ──
                Action::Transform { operations } => {
                    if let Some(mut resp_json) = parsed_resp_body.clone() {
                        let mut resp_header_mutations = middleware::redact::HeaderMutations::default();
                        for op in operations {
                            middleware::redact::apply_transform(&mut resp_json, &mut resp_header_mutations, op);
                        }
                        tracing::info!(
                            policy = %triggered.policy_name,
                            ops = operations.len(),
                            "applied post-flight transform operations"
                        );
                        if let Ok(new_body) = serde_json::to_vec(&resp_json) {
                            resp_body_vec = new_body;
                        }
                    }
                }

                // ConditionalRoute is request-phase only — skip post-flight
                Action::ConditionalRoute { .. } => {
                    tracing::debug!(
                        policy = %triggered.policy_name,
                        "ConditionalRoute is a request-phase action, skipping post-flight"
                    );
                }

                // ── ValidateSchema (post-flight, response-side) ──
                Action::ValidateSchema { schema, not, message } => {
                    if let Some(ref resp_json) = parsed_resp_body {
                        let result = middleware::guardrail::validate_schema(resp_json, schema);
                        // `not` mode: invert – pass only if validation FAILS
                        let should_deny = if *not { result.valid } else { !result.valid };
                        if should_deny {
                            let default_msg = if *not {
                                "Response matches a forbidden schema pattern".to_string()
                            } else {
                                format!(
                                    "Response failed JSON schema validation: {}",
                                    result.errors.join("; ")
                                )
                            };
                            let reason = message.clone().unwrap_or(default_msg);
                            tracing::warn!(
                                policy = %triggered.policy_name,
                                errors = ?result.errors,
                                not = not,
                                "schema validation blocked response"
                            );
                            return Err(AppError::PolicyDenied {
                                policy: triggered.policy_name.clone(),
                                reason,
                            });
                        } else {
                            tracing::debug!(
                                policy = %triggered.policy_name,
                                not = not,
                                "response passed schema validation"
                            );
                        }
                    }
                }

                Action::ExternalGuardrail { vendor, endpoint, api_key_env, threshold, on_fail } => {
                    let text = parsed_resp_body.as_ref()
                        .map(|v| v.to_string())
                        .unwrap_or_else(|| String::from_utf8_lossy(&resp_body_vec).to_string());
                    match middleware::external_guardrail::check(
                        vendor, endpoint, api_key_env.as_deref(), *threshold, &text
                    ).await {
                        Ok(result) if result.blocked => {
                            tracing::warn!(
                                policy = %triggered.policy_name,
                                vendor = ?vendor,
                                label = %result.label,
                                score = %result.score,
                                "ExternalGuardrail: post-flight violation detected"
                            );
                            if on_fail != "log" {
                                return Err(AppError::PolicyDenied {
                                    policy: triggered.policy_name.clone(),
                                    reason: format!("external_guardrail({:?}): {}", vendor, result.label),
                                });
                            }
                        }
                        Ok(_) => {} // clean
                        Err(e) => {
                            tracing::error!(
                                policy = %triggered.policy_name,
                                vendor = ?vendor,
                                error = %e,
                                "ExternalGuardrail: post-flight vendor call failed (fail-open)"
                            );
                        }
                    }
                }

                _ => {
                    tracing::debug!(
                        policy = %triggered.policy_name,
                        action = ?triggered.action,
                        "post-flight action not applicable"
                    );
                }

            }
        }

        // Collect post-flight shadow violations
        if !post_outcome.shadow_violations.is_empty() {
            shadow_violations.extend(post_outcome.shadow_violations);
        }
    }

    // -- 6. Sanitize response --
    let content_type = resp_headers
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let sanitization_result = middleware::sanitize::sanitize_response(&resp_body_vec, content_type);
    let sanitized_body = sanitization_result.body;

    // -- 6.1 Calculate Cost & Update Spend --
    let mut estimated_cost_usd = None;
    let mut audit_prompt_tokens: Option<u32> = None;
    let mut audit_completion_tokens: Option<u32> = None;
    let mut audit_model: Option<String> = None;

    // TEST HOOK: Allow forcing cost/tokens via header for deterministic testing
    if let Some((p, c)) = test_tokens_override {
        audit_prompt_tokens = Some(p);
        audit_completion_tokens = Some(c);
        // Provide a default model if overriding tokens so the dashboard looks normal
        audit_model = Some(detected_model.clone());
    }
    
    if let Some(cost_val) = test_cost_override {
        estimated_cost_usd = Some(cost_val);
        let cost_f64 = cost_val.to_f64().unwrap_or(0.0);
        let _ = middleware::spend::check_and_increment_spend(
            &state.cache,
            state.db.pool(),
            &token.id,
            cost_f64,
        )
        .await;
    }

    if estimated_cost_usd.is_none() {
        match extract_usage(&token.upstream_url, &sanitized_body) {
            Ok(Some((input, output))) => {
                audit_prompt_tokens = Some(input);
                audit_completion_tokens = Some(output);
                let model = extract_model(&sanitized_body).unwrap_or("unknown".to_string());
                audit_model = Some(model.clone());
                let provider = if token.upstream_url.contains("anthropic") {
                    "anthropic"
                } else {
                    "openai"
                };
                let final_cost = cost::calculate_cost(provider, &model, input, output);

                if !final_cost.is_zero() {
                    estimated_cost_usd = Some(final_cost);
                    let cost_f64 = final_cost.to_f64().unwrap_or(0.0);
                    if let Err(e) = middleware::spend::check_and_increment_spend(
                        &state.cache,
                        state.db.pool(),
                        &token.id,
                        cost_f64,
                    )
                    .await
                    {
                        tracing::error!("Spend cap exceeded or tracking failed: {}", e);
                    }
                }
            }
            Ok(None) => {}
            Err(e) => tracing::warn!("Failed to extract usage: {}", e),
        }
    }

    // ── Phase 4: Calculate TPS ────────────────────────────────
    let elapsed_secs = start.elapsed().as_secs_f32();
    let tokens_per_second = audit_completion_tokens.map(|ct| {
        if elapsed_secs > 0.0 { ct as f32 / elapsed_secs } else { 0.0 }
    });

    // ── Phase 4: Privacy-gated body capture ───────────────────
    let log_level = token.log_level as u8;
    let (logged_req_body, logged_resp_body, logged_req_headers, logged_resp_headers) = match log_level {
        0 => (None, None, None, None),
        1 => {
            // Level 1: Run PII scrubbers on bodies
            let req = middleware::redact::redact_for_logging(&parsed_body);
            let resp = middleware::redact::redact_for_logging(&parsed_resp_body);
            (req, resp, None, None)
        }
        2 => {
            // Level 2: Full debug — store raw bodies + headers (auto-expires in 24h)
            let req = parsed_body.as_ref().map(|v| serde_json::to_string(v).unwrap_or_default());
            let resp = parsed_resp_body.as_ref().map(|v| serde_json::to_string(v).unwrap_or_default());
            let req_hdrs = Some(headers_to_json(&headers));
            let resp_hdrs = Some(headers_to_json_reqwest(&resp_headers));
            (req, resp, req_hdrs, resp_hdrs)
        }
        _ => (None, None, None, None),
    };

    // ── Phase 5: LLM Observability extraction ─────────────────
    let llm_tool_calls = parsed_resp_body.as_ref()
        .map(|body| crate::models::llm::extract_tool_calls_from_value(body))
        .unwrap_or_default();
    let llm_finish_reason = parsed_resp_body.as_ref()
        .and_then(|body| crate::models::llm::extract_finish_reason_from_value(body));
    let llm_error_type = if !status.is_success() {
        let body_str = parsed_resp_body.as_ref()
            .map(|v| v.to_string())
            .unwrap_or_default();
        crate::models::llm::classify_error_from_str(status.as_u16(), &body_str)
    } else {
        None
    };
    let tool_call_count = llm_tool_calls.len() as u16;
    let tool_calls_json = if llm_tool_calls.is_empty() {
        None
    } else {
        serde_json::to_value(&llm_tool_calls).ok()
    };

    // -- 7. Emit audit log --
    let mut audit = base_audit(
        request_id, token.project_id, &token.id, agent_name, method.as_str(), &path,
        &upstream_url, &policies, hitl_required, hitl_decision, hitl_latency_ms,
        user_id, tenant_id, external_request_id,
        session_id, parent_span_id,
        custom_properties.clone(),
    );
    audit.policy_result = Some(if hitl_required {
        crate::models::audit::PolicyResult::HitlApproved
    } else {
        crate::models::audit::PolicyResult::Allow
    });
    audit.upstream_status = Some(status.as_u16());
    audit.response_latency_ms = test_latency_override.unwrap_or_else(|| start.elapsed().as_millis() as u64);
    audit.fields_redacted = if sanitization_result.redacted_types.is_empty() {
        None
    } else {
        Some(sanitization_result.redacted_types)
    };
    audit.shadow_violations = if shadow_violations.is_empty() {
        None
    } else {
        Some(shadow_violations)
    };
    audit.estimated_cost_usd = estimated_cost_usd;
    // Phase 4
    audit.log_level = log_level;
    audit.request_body = logged_req_body;
    audit.response_body = logged_resp_body;
    audit.request_headers = logged_req_headers;
    audit.response_headers = logged_resp_headers;
    audit.prompt_tokens = audit_prompt_tokens;
    audit.completion_tokens = audit_completion_tokens;
    let audit_model_for_cache = audit_model.clone();
    audit.model = audit_model;
    audit.tokens_per_second = tokens_per_second;
    // Phase 5
    audit.tool_calls = tool_calls_json;
    audit.tool_call_count = tool_call_count;
    audit.finish_reason = llm_finish_reason;
    audit.error_type = llm_error_type;
    audit.is_streaming = is_streaming_req;
    audit.cache_hit = false; // not a cache hit — we went to upstream
    audit.experiment_name = experiment_name;
    audit.variant_name = variant_name;
    let session_id_for_spend = audit.session_id.clone();
    audit.emit(&state);

    // -- Session spend increment (non-streaming) --
    // session_id was consumed by audit builder above, so we use the clone
    if let Some(ref sid) = session_id_for_spend {
        let cost = estimated_cost_usd.unwrap_or_default();
        let tokens = audit_prompt_tokens.unwrap_or(0) as i64 + audit_completion_tokens.unwrap_or(0) as i64;
        let state_for_session = state.clone();
        let sid_owned = sid.clone();
        let project_id = token.project_id;
        tokio::spawn(async move {
            if let Err(e) = state_for_session.db.increment_session_spend(&sid_owned, project_id, cost, tokens).await {
                tracing::warn!(session_id = %sid_owned, error = %e, "Failed to increment session spend");
            }
        });
    }

    // ── Response Cache: store successful, non-streaming responses ──
    if let Some(ref key) = cache_key {
        if status.is_success() {
            let cached = proxy::response_cache::CachedResponse {
                status: status.as_u16(),
                body: sanitized_body.clone(),
                content_type: content_type.to_string(),
                model: audit_model_for_cache,
                prompt_tokens: audit_prompt_tokens,
                completion_tokens: audit_completion_tokens,
            };
            let state_ref = state.clone();
            let key = key.clone();
            tokio::spawn(async move {
                proxy::response_cache::set_cached(
                    &state_ref.cache,
                    &key,
                    &cached,
                    proxy::response_cache::DEFAULT_CACHE_TTL_SECS,
                ).await;
            });
        }
    }

    // -- Build response --
    let axum_status =
        StatusCode::from_u16(status.as_u16()).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);

    let mut response = Response::builder().status(axum_status);

    for (key, value) in resp_headers.iter() {
        if let Ok(name) = axum::http::HeaderName::from_bytes(key.as_str().as_bytes()) {
            if let Ok(val) = axum::http::HeaderValue::from_bytes(value.as_bytes()) {
                if !matches!(
                    name.as_str(),
                    "server"
                        | "x-request-id"
                        | "x-powered-by"
                        | "content-length"
                        | "transfer-encoding"
                ) {
                    response = response.header(name, val);
                }
            }
        }
    }

    // -- Circuit breaker visibility headers --
    // X-AILink-Upstream: which upstream was selected for this request
    // X-AILink-CB-State: closed | open | half_open | disabled
    // X-Request-Id: correlation ID for debugging and support
    let cb_state: &'static str = if cb_config.enabled {
        state.lb.get_circuit_state(&token.id, &final_upstream_url, cb_config.recovery_cooldown_secs)
    } else {
        "disabled"
    };
    response = response.header("x-ailink-cb-state", axum::http::HeaderValue::from_static(cb_state));
    if let Ok(upstream_hv) = axum::http::HeaderValue::from_str(&final_upstream_url) {
        response = response.header("x-ailink-upstream", upstream_hv);
    }
    // DynamicRoute observability: tell developers which strategy won and why
    if let Some(ref strategy) = dynamic_route_strategy {
        if let Ok(hv) = axum::http::HeaderValue::from_str(strategy) {
            response = response.header("x-ailink-route-strategy", hv);
        }
    }
    if let Some(ref reason) = dynamic_route_reason {
        if let Ok(hv) = axum::http::HeaderValue::from_str(reason) {
            response = response.header("x-ailink-route-reason", hv);
        }
    }
    // Attach request ID to every response for support correlation
    let req_id_str = format!("req_{}", request_id.simple());
    if let Ok(req_id_hv) = axum::http::HeaderValue::from_str(&req_id_str) {
        response = response.header("x-request-id", req_id_hv);
    }

    // -- Budget-remaining headers (best-effort, non-blocking) --
    // Lets developers know how much headroom they have left without polling the API.
    // We read from Redis which is already primed by check_and_increment_spend.
    if let Ok(status) = middleware::spend::get_spend_status(
        state.db.pool(),
        &state.cache,
        &token.id,
    ).await {
        if let Some(daily_limit) = status.daily_limit_usd {
            let remaining = (daily_limit - status.current_daily_usd).max(0.0);
            if let Ok(hv) = axum::http::HeaderValue::from_str(&format!("{:.4}", remaining)) {
                response = response.header("x-ailink-budget-remaining-daily", hv);
            }
        }
        if let Some(monthly_limit) = status.monthly_limit_usd {
            let remaining = (monthly_limit - status.current_monthly_usd).max(0.0);
            if let Ok(hv) = axum::http::HeaderValue::from_str(&format!("{:.4}", remaining)) {
                response = response.header("x-ailink-budget-remaining-monthly", hv);
            }
        }
        if let Some(lifetime_limit) = status.lifetime_limit_usd {
            let remaining = (lifetime_limit - status.current_lifetime_usd).max(0.0);
            if let Ok(hv) = axum::http::HeaderValue::from_str(&format!("{:.4}", remaining)) {
                response = response.header("x-ailink-budget-remaining-lifetime", hv);
            }
        }
    }

    // P1.7: Attach idempotency warning if retries were skipped for safety
    if let Some(warning_msg) = idempotency_warning {
        if let Ok(warning_hv) = axum::http::HeaderValue::from_str(warning_msg) {
            response = response.header("x-ailink-warning", warning_hv);
        }
    }

    // ── Feature 8: Async Guardrails ──────────────────────────────────────────
    // Spawn background evaluation for rules that opted into async_check=true.
    // The response is committed before these are evaluated — violations are
    // logged and trigger audit/webhook events but cannot block the response.
    if !pre_async_triggered.is_empty() {
        let state_async = state.clone();
        let token_id_async = token.id.clone();
        let async_triggered = pre_async_triggered;
        // Snapshot the sanitized body for async guardrail content checks
        let async_body_snapshot = parsed_body.clone();
        tokio::spawn(async move {
            for triggered in &async_triggered {
                tracing::info!(
                    token_id = %token_id_async,
                    policy = %triggered.policy_name,
                    rule = triggered.rule_index,
                    action = ?triggered.action,
                    "async guardrail: evaluating non-blocking rule"
                );
                // Re-evaluate content filter / validate_schema actions
                // on the captured body. Other action types (rate_limit, deny,
                // webhook, etc.) are executed directly.
                match &triggered.action {
                    crate::models::policy::Action::ContentFilter { .. } => {
                        if let Some(ref body) = async_body_snapshot {
                            let result = crate::middleware::guardrail::check_content(body, &triggered.action);
                            if result.blocked {
                                tracing::warn!(
                                    token_id = %token_id_async,
                                    policy = %triggered.policy_name,
                                    risk_score = %result.risk_score,
                                    patterns = ?result.matched_patterns,
                                    "async guardrail: content filter VIOLATION (response already sent)"
                                );
                                // Emit async violation audit
                                let event = crate::models::audit::AsyncGuardrailViolation {
                                    token_id: token_id_async.clone(),
                                    policy_name: triggered.policy_name.clone(),
                                    matched_patterns: result.matched_patterns,
                                    risk_score: result.risk_score,
                                };
                                crate::models::audit::emit_async_violation(event).await;
                            }
                        }
                    }
                    crate::models::policy::Action::ValidateSchema { schema, not, .. } => {
                        if let Some(ref body) = async_body_snapshot {
                            let result = crate::middleware::guardrail::validate_schema(body, schema);
                            let violated = if *not { result.valid } else { !result.valid };
                            if violated {
                                tracing::warn!(
                                    token_id = %token_id_async,
                                    policy = %triggered.policy_name,
                                    errors = ?result.errors,
                                    "async guardrail: schema validation VIOLATION (response already sent)"
                                );
                            }
                        }
                    }
                    crate::models::policy::Action::Webhook { url, timeout_ms, .. } => {
                        // Fire webhook asynchronously
                        let w_url = url.clone();
                        let w_timeout = *timeout_ms;
                        let _ = reqwest::Client::new()
                            .post(&w_url)
                            .timeout(std::time::Duration::from_millis(w_timeout))
                            .json(&serde_json::json!({"event": "async_guardrail_webhook"}))
                            .send()
                            .await;
                    }
                    _other => {
                        tracing::debug!(
                            token_id = %token_id_async,
                            policy = %triggered.policy_name,
                            "async guardrail: action type not evaluated asynchronously"
                        );
                    }
                }
            }
        });
    }

    response
        .body(Body::from(sanitized_body))
        .map_err(|e| AppError::Internal(anyhow::anyhow!("response build failed: {}", e)))
}

/// Builder for audit log entries. Avoids 25+ positional arguments.
#[derive(Default)]
struct AuditBuilder {
    req_id: Option<Uuid>,
    project_id: Option<Uuid>,
    token_id: String,
    agent_name: Option<String>,
    method: String,
    path: String,
    upstream_url: String,
    policies: Vec<String>,
    policy_result: Option<crate::models::audit::PolicyResult>,
    hitl_required: bool,
    hitl_decision: Option<String>,
    hitl_latency_ms: Option<i32>,
    upstream_status: Option<u16>,
    response_latency_ms: u64,
    fields_redacted: Option<Vec<String>>,
    shadow_violations: Option<Vec<String>>,
    estimated_cost_usd: Option<rust_decimal::Decimal>,
    // Phase 4
    log_level: u8,
    request_body: Option<String>,
    response_body: Option<String>,
    request_headers: Option<serde_json::Value>,
    response_headers: Option<serde_json::Value>,
    prompt_tokens: Option<u32>,
    completion_tokens: Option<u32>,
    model: Option<String>,
    tokens_per_second: Option<f32>,
    user_id: Option<String>,
    tenant_id: Option<String>,
    external_request_id: Option<String>,
    // Phase 5: LLM Observability
    tool_calls: Option<serde_json::Value>,
    tool_call_count: u16,
    finish_reason: Option<String>,
    session_id: Option<String>,
    parent_span_id: Option<String>,
    error_type: Option<String>,
    is_streaming: bool,
    ttft_ms: Option<u64>,
    cache_hit: bool,
    // A/B experiment tracking
    experiment_name: Option<String>,
    variant_name: Option<String>,
    // Phase 6: Just Enough Observability
    custom_properties: Option<serde_json::Value>,
}

impl AuditBuilder {
    fn emit(self, state: &AppState) {
        let entry = crate::models::audit::AuditEntry {
            request_id: self.req_id.unwrap_or_else(Uuid::new_v4),
            project_id: self.project_id.unwrap_or_default(),
            token_id: self.token_id,
            agent_name: self.agent_name,
            method: self.method,
            path: self.path,
            upstream_url: self.upstream_url,
            request_body_hash: None,
            policies_evaluated: Some(serde_json::json!(self.policies)),
            policy_result: self.policy_result.unwrap_or(crate::models::audit::PolicyResult::Allow),
            hitl_required: self.hitl_required,
            hitl_decision: self.hitl_decision,
            hitl_latency_ms: self.hitl_latency_ms,
            upstream_status: self.upstream_status,
            response_latency_ms: self.response_latency_ms,
            fields_redacted: self.fields_redacted,
            shadow_violations: self.shadow_violations,
            estimated_cost_usd: self.estimated_cost_usd,
            timestamp: chrono::Utc::now(),
            log_level: self.log_level,
            request_body: self.request_body,
            response_body: self.response_body,
            request_headers: self.request_headers,
            response_headers: self.response_headers,
            prompt_tokens: self.prompt_tokens,
            completion_tokens: self.completion_tokens,
            model: self.model,
            tokens_per_second: self.tokens_per_second,
            user_id: self.user_id,
            tenant_id: self.tenant_id,
            external_request_id: self.external_request_id,
            tool_calls: self.tool_calls,
            tool_call_count: self.tool_call_count,
            finish_reason: self.finish_reason,
            session_id: self.session_id,
            parent_span_id: self.parent_span_id,
            error_type: self.error_type,
            is_streaming: self.is_streaming,
            ttft_ms: self.ttft_ms,
            cache_hit: self.cache_hit,
            experiment_name: self.experiment_name,
            variant_name: self.variant_name,
            custom_properties: self.custom_properties,
            payload_url: None, // set by audit middleware after potential offload
        };
        middleware::audit::log_async(
            state.db.pool().clone(),
            state.payload_store.clone(),
            entry,
        );
    }
}

/// Helper to create a pre-populated AuditBuilder from shared request context.
fn base_audit(
    req_id: Uuid,
    project_id: Uuid,
    token_id: &str,
    agent_name: Option<String>,
    method: &str,
    path: &str,
    upstream_url: &str,
    policies: &[crate::models::policy::Policy],
    hitl_required: bool,
    hitl_decision: Option<String>,
    hitl_latency_ms: Option<i32>,
    user_id: Option<String>,
    tenant_id: Option<String>,
    external_request_id: Option<String>,
    session_id: Option<String>,
    parent_span_id: Option<String>,
    custom_properties: Option<serde_json::Value>,
) -> AuditBuilder {
    AuditBuilder {
        req_id: Some(req_id),
        project_id: Some(project_id),
        token_id: token_id.to_string(),
        agent_name,
        method: method.to_string(),
        path: path.to_string(),
        upstream_url: upstream_url.to_string(),
        policies: policies.iter().map(|p| p.name.clone()).collect(),
        hitl_required,
        hitl_decision,
        hitl_latency_ms,
        user_id,
        tenant_id,
        external_request_id,
        session_id,
        parent_span_id,
        custom_properties,
        ..Default::default()
    }
}

/// Convert axum HeaderMap to JSON object for Level 2 logging.
fn headers_to_json(headers: &HeaderMap) -> serde_json::Value {
    let mut map = serde_json::Map::new();
    for (key, value) in headers.iter() {
        if let Ok(v) = value.to_str() {
            // Skip authorization to never log real credentials
            if key.as_str().eq_ignore_ascii_case("authorization") {
                map.insert(key.to_string(), serde_json::json!("[REDACTED]"));
            } else {
                map.insert(key.to_string(), serde_json::json!(v));
            }
        }
    }
    serde_json::Value::Object(map)
}

/// Convert reqwest HeaderMap to JSON object for Level 2 logging.
fn headers_to_json_reqwest(headers: &reqwest::header::HeaderMap) -> serde_json::Value {
    let mut map = serde_json::Map::new();
    for (key, value) in headers.iter() {
        if let Ok(v) = value.to_str() {
            map.insert(key.to_string(), serde_json::json!(v));
        }
    }
    serde_json::Value::Object(map)
}

fn extract_bearer_token(headers: &HeaderMap) -> Result<String, AppError> {
    let auth = headers
        .get("authorization")
        .and_then(|v| v.to_str().ok())
        .ok_or(AppError::TokenNotFound)?;

    if !auth.starts_with("Bearer ") {
        return Err(AppError::TokenNotFound);
    }
    let token = auth[7..].trim().to_string();
    if !token.starts_with("ailink_v1_") {
        return Err(AppError::TokenNotFound);
    }
    Ok(token)
}

/// SEC: Validate that a webhook URL from a policy definition is safe to call.
/// Blocks private IPs, cloud metadata endpoints, and non-HTTP(S) schemes.
fn is_safe_webhook_url(url_str: &str) -> bool {
    let parsed = match reqwest::Url::parse(url_str) {
        Ok(u) => u,
        Err(_) => return false,
    };

    // Only allow HTTP(S)
    if parsed.scheme() != "http" && parsed.scheme() != "https" {
        return false;
    }

    let host = match parsed.host_str() {
        Some(h) => h,
        None => return false,
    };

    // Block known cloud metadata endpoints
    let blocked_hosts = [
        "169.254.169.254",
        "metadata.google.internal",
        "metadata.internal",
        "0.0.0.0",
    ];
    if blocked_hosts.contains(&host) {
        return false;
    }

    // Block private/reserved IP ranges
    if let Ok(ip) = host.parse::<std::net::IpAddr>() {
        let is_private = match ip {
            std::net::IpAddr::V4(v4) => {
                v4.is_loopback()
                    || v4.is_private()
                    || v4.is_link_local()
                    || v4.octets()[0] == 169 && v4.octets()[1] == 254
            }
            std::net::IpAddr::V6(v6) => v6.is_loopback(),
        };
        if is_private {
            return false;
        }
    }

    true
}
